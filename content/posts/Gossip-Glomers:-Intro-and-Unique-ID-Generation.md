---
title: "Gossip Glomers: Intro and Unique ID Generation"
description: >-
  Who knew you could practice implementing distributed systems for fun?
date: 2023-11-26T21:06:12-08:00
categories:
  - Academic
tags:
  - Distributed systems
  - fly.io
  - Gossip Glomers
draft: true
---

One of the challenges for practicing implementation distributed systems is that it is not easy to simulate the various situations a distributed system might find itself in. Moreover, I previously could not even come up with an easy way to deploy a toy setup; the only thing I could think of is to use [minikube](https://minikube.sigs.k8s.io/docs/), but frankly at that point it is too much investment for me[^0].

Fortunately, I recently came across a series of distributed systems challenges created by [fly.io](https://fly.io/) and [Kyle Kingsbury](https://aphyr.com/about) (author of [Jepsen](https://jepsen.io/)): [Gossip Glomers](https://fly.io/dist-sys/). The challenges use [Maelstrom](https://github.com/jepsen-io/maelstrom), a framework for running and testing toy implementations of distributed systems, so that you only have to implement the individual nodes and not worry about anything else. Even better, Maelstrom provides a [Go library](https://pkg.go.dev/github.com/jepsen-io/maelstrom/demo/go) containing the boilerplate for creating Maelstrom Nodes, leaving you to focus on the fun stuff[^1]!

With this being so accessible, I guess I'll be working through the Gossip Glomers as I get time. When I complete a challenge, I'll also write a post about my thought process[^2]! My code can be found at [https://github.com/lynshi/gossip-glomers](https://github.com/lynshi/gossip-glomers).

---
Challenge 2 is [Unique ID Generation](https://fly.io/dist-sys/2/). The system must generate globally unique IDs and be totally available, so network partitions must not lead to violation of the uniqueness constraint.

In order to be resilient to partitions, we cannot rely on node-to-node communication to synchronize the list of used IDs. One way of ensuring that nodes do not generate conflicting IDs is to split the range of possible IDs across nodes so that none of the ranges overlap.

While the obvious approach is to split the pool of possible IDs in 3[^3], an easier to implement (and subjectively more elegant) method is to have a unique prefix for each node. The prefix can be derived from the node ID (nodes are numbered `n1`, `n2`, ...). Then, when asked for an ID, each node will return a locally-unique ID prefixed with its node ID. For example, the first ID generated by node 1 might look like `1-0`.

---

Upon rereading the prompt, I realized that IDs may be of any type, so the format `<node ID>.<locally incrementing index>` suffices to solve the problem. However, I completedly missed this as I was working on it, so I came up with a scheme to create integer IDs.

Since the test sends 1000 requests per second for 30 seconds, the system is expected to generate 30,000 unique IDs. This means that the set of ID numbers generated by each node must include the range `[0, 30000)`; this fits in a 15-bit number (`2^15 = 32768`). Then, to generate a globally unique ID from a locally unique one, we left-shift the node ID prefix by 15 bits and add the locally unique ID. Overall, our ID generator generates 17-bit IDs[^4].

<!--- Footnotes -->

[^0]: We haven't even gotten to how to create and run proper tests yet!
[^1]: Plus the added benefit of getting to use Go ðŸ¤£
[^2]: The [first challenge](https://fly.io/dist-sys/1/) is just a "Hello, World!" for getting you set up, so I'll skip it.
[^3]: In this challenge, there are only three nodes.
[^4]: The first two bits will be used for the unique prefix (`00`, `01`, and `10`).
